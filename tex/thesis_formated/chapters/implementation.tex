\chapter{Implementation}
  \label{subsec:implementation}
  This chapter describes the development process and shows the solution and implementation of specific problems, that appeared while implementing the application. The first challenge was to integrate the Henshin \acs{sdk} into the \ac{glsp} project. Another challenge was to index the elements of the different \ac{emf} models and formats. One big UI desicion was where to place the selection of transformation rules in the application.

  \section{Development Process}
  \label{subsec:development-process}
  The development of the Henshin Web \ac{glsp} editor was done by one person in a time span of about 6 months. Derived from the functional requirements (see section \ref{subsec:functional-requirements}) the project was split into 7 milestones. The milestones were defined as follows:
  \begin{itemize}
    \item \textbf{Milestone 1:} Setup the project and create a diagram editor that can display \textit{.xmi} files.
    \item \textbf{Milestone 2:} Create editing capabilities for \ac{xmi} instance files.
    \item \textbf{Milestone 3:} Henshin transformation rules can be displayed and applied to the instance model.
    \item \textbf{Milestone 4:} Create an additional diagram editor that can display Henshin rules.
    \item \textbf{Milestone 5:} Create an additional diagram editor that can display Ecore metamodels.
    \item \textbf{Milestone 6:} Create editing capabilities for Henshin rules.
    \item \textbf{Milestone 7:} Create editing capabilities for Ecore metamodels.
  \end{itemize}

  Each milestone was split into smaller issues. The first milestone was used to create \ac{poc} to test the integration of Henshin into a \ac{glsp} project. In this phase, the focus was to get to now how the frameworks \ac{emf}, \ac{glsp}, Henshin and Eclipse Theia work. Even though \ac{glsp} provides a well structured documentation and project templates, they didn't cover many use cases for the development of Henshin Web. Henshin also doesn't provide an documentation of their \acs{api}. Therefore for these frameworks a lot of source code reading and understanding was needed. 
  Git was used as a version control system. The development of a milestone was don in a seperate development branch. When all features of the milestone were implemented, the state of the application was additionally tested and then merged into the main branch.

  \section{Tooling and Environment}
  \label{subsec:tooling}
  For the development of Henshin Web, \ac{vscode} \cite{vscode} was used to develop the client and InteliJ IDEA \cite{intellij} was used to develop the Java server.
  For understanding the source code of not well documented frameworks, the use of Chatbot Agents was very helpful. I used Github Copilot in \ac{vscode} with the model Claude Sonnet 4 \cite{claude_sonnet} in agent mode. Because it has access to the source code of the dependend frameworks, it can search for specific classes or methods or explain certain concepts.
  Git was used as version control system and GitLab was used as a remote repository. It was also used for the project management, where the milestones were defined and the issues were created. A issue board was used to show the current sate and progress of the project. The GitLab package registry was also used to store the Henshin maven packages, to be able to access them from the \ac{glsp} project. These packages are then available to every contributor of the GitLab, that want to develop on the project. More about the creation on Maven packages will be shown in the next section.

  \section{Code Examples...}
  \label{subsec:code-examples}

  This section shows the solution and implementation of specific problems, that occured during the development process.

  \subsection{Integration of Henshin into a GLSP project} 
  \label{subsec:henshin-glsp}

  The Henshin source code provides both the Eclipse \ac{ide} plugin and a Java SDK for using the Henshin interpreter. The project of Henshin is structured as an Eclipse project and is available as a set of Eclipse plugins and features. \cite{henshin-repo} On the other hand, \ac{glsp} projects typically use a Maven project structure. \cite{glsp-repo} To add dependencies to a Maven project, the dependencies should ideally be available as Maven artifacts. However, Henshin doesn't provide a Maven artifact, since that is not needed for an Eclipse plugin. The Henshin version 1.8.0 is compatible with \acs{jdk} 11 and higher. \ac{glsp} version 2.3.0 has the prerequisite of \acs{jdk} 17. Therefore, the versions are compatible to run together. The Henshin code consists of 45 plugins, of which 22 are contained in the Henshin SDK, that we need as a dependency in our Henshin Web \ac{glsp} project. Each plugin can be downloaded as a \acs{jar} file. To create Maven packages from the \acsp{jar}, a PowerShell script is used. It reads all \acsp{jar} files from a folder, renames them to the correct Maven artifact name, creates a basic \code{pom.xml} file for them, deploys them to the GitLab package repository, and creates a list that needs to be included in the Maven \code{pom.xml} file of the \ac{glsp} project. A package of each plugin is created, because for the Henshin Web editor, only some parts of the Henshin SDK are needed. To use the Henshin model package, the additional dependency of the Nashorn JavaScript engine \cite{nashorn-repo} is needed. The Nashorn engine is used to execute calculation expressions of transformation rules. \cite{henshin}

  \subsection{GModelFactory}
  \label{subsec:gmodel-factory}

  The heart of a \ac{glsp} server diagram module is the \code{GModelFactory}. It is responsible for creating the graphical model from the source model. In listing \ref{lst:gmodel-factory} you can see the implementation of parts of the creation of the graphical nodes. The method \code{fillRootElement(GmodelRoot newRoot)} gets called when a new graphical model should be created. It fetches the source model elements from the \code{ModelState}, iterates over them, and creates \code{GNode} elements using a builder pattern. In the method \code{createNode(DynamicEObjectImpl eObject)}, it is configured how the node should look in the editor. It sets the id, adds \acs{css} classes and  configures rounded corners. It also sets the type of the node. The type can be a default type, or custom types, that have their own customized client implementation. In listing \ref{lst:gmodel-factory} you can see for example that the root node of the \ac{xmi} instance model gets a different type. The type is used to configure that only one root node can exist and that it cannot be deleted, if other child nodes exist. The method \code{applyShapeData(eObject)} adds the layout information from the notation model. In the \code{GNodeBuilder} also the builded child elements like the header or the attributes are added. This creates a tree strucutre of graphical elements, that are all atached to the \code{GModelRoot}. The \code{RuleGModelFactory} and the \code{EcoreGModelFactory} work similar to the \code{XMIGModelFactory}, but they create different node types and handle the source model elements differently.


  \subsection{Layouting}
  \label{subsec:layouting}

  \ac{emf} Ecore metamodel files (\textit{.ecore}), Henshin rule files (\textit{.henshin}) and \ac{emf} instance files (\textit{.xmi}), don't contain information about the position or size of elements in a graph. \cite{emf,henshin-repo} To provide a good user experience, the graphical editors need to provide a consistent macro layout for nodes and edges. Newly created nodes should not overlap with existing nodes, and the nodes should stay in the same place after reloading the editor. In general, the \ac{glsp} server is responsible for the macro layouting. \cite{glsp-doc} \ac{glsp} provides multiple options to layout the graph. The interface \code{LayoutEngine} can be used to create a custom layout algorithm, that is applied after the creation of the graphical model from the source model. \ac{glsp} provides the \code{ElkLayoutEngine} implementation, that uses the \ac{elk} to layout the graphical model. \cite{elk-engine} With \ac{elk}, different layout algorithms can be used and additionally configured. Even though \ac{elk} provides much flexibility for the layout, the layout is newly created after every change to the source model. This means that the layout is not consistent and nodes can move around after every change. To provide a consistent layout, the position of nodes need to be stored in addition to the source model. The \ac{glsp} server provides a notation model, that can be used to store the position and size of nodes and edges. \cite{glsp-repo} This brings the overhead of updating the notation model every time when the source model is updated. \ac{glsp} provides classes to make the synchronization of the notation model easier. The notation model is stored in an additional \textit{.notation} file, that is loaded together with the source model and applied to the graphical model in the \code{GModelFactory} using the \code{NotationUtil.applyShapeData(shape, builder)} method. To capture changes of position and size of nodes, the \ac{glsp} client sends the \code{ChangeRoutingPointsOperation} and \code{ChangeBoundsOperation} operations automatically when moving or resizing a node or edge. At the server, the corresponding handlers are updating the notation model using commands to provide undo and redo functionalities.

  To achieve layouting in the Henshin Web editor, notation models for the metamodel, Henshin rules, and instances are used. The \textit{.notation} file is created when the source model is loaded for the first time. Here, \ac{elk} can be used to create a fitting initial layout. For the \ac{xmi} instance models, when the graphical model gets created in the \code{GModelFactory}, the shape data from the notation model is added to the \ac{emf} elements over an \ac{emf} \code{Adapter}. Each \ac{emf} \code{EObject} has a list of adapters, that can be used to store additional information. \cite{emf} To connect the notation to an element, the \code{NotationAdapter.getOrAssignNotation()} method checks if the element already has a notation, either returning the existing notation or appending a new Adapter with the notation information.
  For the Henshin rules and the Ecore metamodels, the notation element mapping is stored in the model index that is contained in the \code{ModelState}. The reason for the different indexing approaches and their implementations will be explaine in the next section. 


  \subsection{Indexing EMF models}
  \label{subsec:indexing}

  Like the layout information, \ac{emf} Ecore metamodels and \ac{emf} \ac{xmi} instance models don't by default contain unique identifiers for nodes, edges, or attributes. \cite{emf,emf-repo} The graphical model of \ac{glsp} on the other hand uses identifiers for each element that is displayed. If no identifiers are specified when creating the graphical elements, \ac{glsp} generates its own internal unique identifiers. These identifiers are used in edit operations like renaming or deleting a node, where the graphical element needs to be mapped back to the source model element and only the identifier of the graphical element is sent from the client to the server. To be able to map the graphical element back to the source model element, custom identifiers need to be stored. Additionally, during the transformation of the source model into the graphical model, elements need to be accessed multiple times. For example, a source node is accessed over the \ac{emf} package when it is mapped into a \code{GNode} and then again for all its connected edges and attributes. An indexing of the elements avoid multiple lookups in the \ac{emf} source model. To be able to support any created domain meta and instance models and to prevent prerequisites for the use \ac{emf} models in Henshin Web, the \ac{glsp} server needs to create own inexes for the elements of the source model. 

  The idexing of the three different source model types is implemented in differnt ways, due to the different internal structures and stored informations. The simplest approach is used for the Henshin rule model. Henshin already creates identifiers for each node and edge of a transformation rule. These identifiers are also stored in the \textit{.henshin} file. When building the graphical model, the identifiers can be accessed over the method \code{getURIFragment(element)} of the \ac{emf} resource. When a new element is created, the index is stored in a bidirectional hash map in the \code{RuleModelIndex} that is accesible over the \code{ModelState}. This index can also be used for the notation model, where the semantic element id needs to be stored to be able to map the layout information back to the source model element. One problem of storing the Henshin identifiers is that a transformation rule is stored as a \ac{lhs} and \ac{rhs} part. Each part hs its own identifier, even though it is only one element in the graph. For that Henshin also stores mappings of the \ac{lhs} and \ac{rhs} elements in the \textit{.henshin} file. To be able to correctly map the source model elements to the graphical model elements, these mappings are also stored in the \code{RuleModelIndex}. In listing \ref{lst:rule-indexing} you can see the implementation of the methods \code{getRuleElement(id)} and \code{getRuleElementId(element)} that are used to get the element from the index or get the index of an element. You can see that before searching the index, the mapping list is checked to ensure that the \ac{lhs} element is preferably returned, if it exists. That is for example needed for setting the source and target nodes of an edge. If the edge only appears in the \ac{rhs} part and it should get deleted when applying the rule the \code{getSource()} method returns the \ac{rhs} node element, but the source node was initially created from the \ac{lhs} element. Without the mapping, the source node would not be found in the index and therefore creating an new index, that results in a invalid route in the graphical model.

  \input{listings/rule-indexing.tex}


  This problem doesn't appear for the Ecore metamodel indexing because no content independent indexes are stored in the \ac{emf} model. Here the indexing is used from the existing \ac{glsp} Ecore editor \cite{glsp-ecore-repo}. The \code{EcoreModelIndex} stores an index for the semantic elements, the notation elements and an additional index for inheritance edges.
  For the semantic index, random \acp{uuid} are created. They are used until the client session is closed. During this time, operations on the source model can access \ac{emf} elements by their \acp{uuid} over the stored \code{HashMap} and then apply the operation on the \ac{emf} element. The indentifiers are content-independent, which has the advantage, that the identifiers are not changing when nodes are updated. The problem with temporary identifiers on the other hand is, that they cannot be mapped to the source elements after the client session is closed. Therefore, the \acp{uuid} cannot be used in the notation model, because the same notation model needs to be loaded across client sessions. Here, the name of the \ac{emf} class is used, since it is unique for each element in the Ecore metamodel. This index has to be updated if a class is renamed.
  The inheritance index for the Ecore metamodel is used to find already created inheritance edges and retrieve their bend points. With that information, the edges can be connected at bend points to create the typical inheritance arrow structure.

  For the notation models of \ac{xmi} instance models, also content hashes are used as identifiers. Here the name of a object is not unique, because multiple objects of one class can exist. Therefore the content hash, is created from the class name and the names and values of all its attributes. A hash for the class \textit{Client} can look like this: \textit{Client:DynamicEObjectImpl-name:EString=Alice} This content hashes is generated every time the graphical model is created for the first time in a session. It needs to be updated when a attribute value is changed. Content hashes for edges would be even more complex, because they need to include the source and target node hashes combined with the edge type. This is also a reason, why the edge layout information is not stored in the notation model, since the hashes need to be changed for many edit operations to the source model. For \ac{xmi} instance elements, the additional use of adapters are used. The \code{NotationAdapter} and the \code{UUIDAdapter} store the index in the Adapter, which is then directly attaced to the \ac{emf} element. This has the advantage, especially for the \code{NotationAdapter}, that when the content hash has to be updated, the notation model can be directly fetched from the \ac{emf} element. It also contains the hashing algorithm for nodes. You can see the implementation of the \code{NotationAdapter} in listing \ref{lst:notation-adapter}. These content hashes need to be used for session independent identifiers, but using them as the only identifier would need a lot of overhead to update the hashes. Therefore, the indexing of the semantic elements works like the metamodel indexing, where \acp{uuid} are used. 
  The combination of the \acp{uuid} and content hashes allows flexibility for editing the source model, while maintaining the connection to the notation model.

  \subsection{Custom UI extensions}
  \label{subsec:custom-ui-extensions}

  This section demonstrates the creation of custom UI extensions by two different examples. \ac{glsp} provides a predefined interface for creating custom UI elements, that could be used in all platoform integrations. For that the abstract class \code{AbstractUIExtension} must be extended and added to the \textit{henshin-glsp} application module. One simple example is the transformation rule name with its parameters that is displayed in the top left of the rule editor. The extension needs a defined id and a parent container id. With the \code{SetUIExtensionVisibilityAction}, the UI element can be made visible from external over the id. With the method \code{initializeContents(containerElement)}, the \acs{html} elements can be created and added to the container. After the model initialization and over a public updated method, the class requests the rule name and its parameters over the \code{IActionDispatcher} and updates the UI. This update method can be called from any other class, when the \code{RuleNameUIExtension} is registered and injected over the dependency injection. One example is the explorer view, where the rule can be opened and therefore the rule name must be updated.
  
  This custom explorer is a Theia exclusive extension, accessing the Theia internal \acsp{api}. It cannot be used for other \ac{glsp} platform integrations. To use a custom theia explorer was already discussed in section \ref{subsec:design-decisions}. To implement a custom explorer, the classes \code{FileNavigatorModel}, \code{FileNavigatorTree}, and \code{FileNavigatorWidget} are extended and registered in the theia specific \textit{rules-theia} module via dependency injection. To add additional virtual elements in the explorer tree, the two new tree nodes \code{HenshinRootNode}, that contains a list of children, and \code{HenshinRuleNode}, that contains information like the rule name, are created. The method \code{resolveChildren(parent)} is overwritten in the \code{FileNavigatorTree}. Here, if it iterates over a \textit{.hensin} file node, it requests the transformation rules from the server and creates the corresponding \code{HenshinRuleNode} for each rule. It creates also an additional node that works as a \glqq{}add rule\grqq{} button. In the \code{HenshinNavigatorWidget}, the method \code{onSelectionChanged} event is subscribed. It checks if a virtual \code{HenshinRuleNode} was selected. If that is the case, it tries to find the \ac{glsp} rule wdiget and opens it. It also sends the selected rule name to the server, that is then selecting the rule in the \code{RuleGModelFactory}, where the graphical model is created. To provide a fitting look to the new tree nodes, the \code{HenshinNavigatorWidget} implements the methods \code{toNodeName(node)} and \code{toNodeIcon(node)}. Here, fitting icons are selected and the displayed names are configured.

    \input{listings/rule-name-extension.tex}