\chapter{Testing and Evaluation}
  \label{sec:testing}

  This chapter discusses the testing strategy of the Henshin Web application. First the general strategy is described. Then the structure of the unit tests and end-to-end tests are separately presented. Finally, manual test cases are presented.


  \section{Testing Strategy}
  \label{subsec:testing-strategy}

The Henshin Web Model Transformation project uses different testing strategies to verify reliability and correctness in both backend and frontend components. The Java backend testing relies on Unit Tests with JUnit 5 combined with Mockito for dependency mocking. The tests were written after the development of each milestone to check that new features work correctly and do not interfere with already existing code. The unit tests focus on backend core features: graphical model generation and handler implementations. Playwright is used to create end-to-end automated \ac{ui} tests. The end-to-end tests verify that individual components are working correctly and also tests the overall system through realistic user interaction scenarios. The tests are following use cases derived from the functional requirements to ensure comprehensive coverage of the critical workflows. All tests were executed regularly during development, especially after a new feature was added to the codebase.

Additionally, some manual test cases were executed to test real-world scenarios. These manual tests focused on the user workflows, visual appearance of elements, and overall usability. Going through these test cases helped to get a feeling for the responsiveness, user experience, optics, and performance of the application.

\section{Unit Tests}
\label{subsec:test-results}

To test the backend components of Henshin Web, unit tests were implemented using JUnit 5 and Mockito. The goal was to achieve high code coverage, especially for the core features like the graphical model generation and the handler, editing the models.

To test the handlers, a test class for each handler was created. Objects like the ModelState, EditingDomain, and EMF resources were mocked using Mockito to isolate the handler logic from external dependencies. For example, in the \code{ApplyRuleOperationHandlerTest}, the ModelState is mocked to provide controlled responses when querying for applicable rules or retrieving model resources. The EditingDomain is also mocked to verify that commands are executed correctly without needing a real EMF editing context.

The graphical model factory logic was tested in classes like \code{EcoreGraphicalModelGeneratorTest} and \code{HenshinGraphicalModelGeneratorTest}. Here, sample Ecore and Henshin models were created programmatically, and the generated graphical models were verified to ensure that all nodes, edges, and attributes were correctly represented. Similar to the handler tests, mocking was used to simulate the behavior of the model state or the indexing.


\section{End-to-end Tests}
\label{subsec:performance-evaluation}

For end-to-end testing, different frameworks were initially considered including Cypress, Playwright and Selenium. After finding the @theia/playwright library \cite{theia-repo}, the decision resulted in using Playwright as a end-to-end testing library. The library is suggested for testing Theia-based applications in the Theia documentation \cite{theia-doc}. The library provides native support for testing Theia-based applications with built-in helpers for common operations and better handling of Theia's asynchronous loading behavior. With the help of the library it is easy to interact with the Theia explorer view, while creating resilient tests with minimal boilerplate code. 

The E2E tests simulate realistic user interactions such as opening the bank example workspace, navigating to \ac{xmi} files, launching the \ac{glsp} diagram editor, interacting with diagram elements, and validating that the elements are displayed correctly. The test configuration supports multiple browsers including Chromium and Firefox, ensuring cross-browser compatibility.

\section{Manual Test Cases}
\label{subsec:test-cases}

To complement the automated tests and validate real-world usage scenarios, a series of manual test cases were executed throughout the development process. These test cases focus on user workflows that are too complex to automate or require human judgment to evaluate, such as visual appearance, performance perception, and overall usability. The following blocks describe key manual test cases that validate the end-to-end functionality of the application.\\

\noindent\textbf{Complete Workflow Test: Project Creation to Rule Application}

The first manual test case covers the whole process of working with Henshin Web. It involves creating a complete project from scratch and testing the entire transformation workflow. This test case validates the integration of all major components of the system and ensures that the requirements for metamodel editing, transformation rule creation, and rule application are properly implemented. These are the necessary steps of the test case:

\begin{enumerate}
    \item \textbf{Project Creation:} Create a new project folder in the application using the file explorer functionality. This step validates requirement \ref{r:project-manage}.

    \item \textbf{Metamodel Creation:} Open the Ecore metamodel file and create multiple class nodes, references and attributes (e.g., a simple banking domain with \texttt{Account} and \texttt{Customer} classes), set appropriate data types for attributes, and save the metamodel file. This step validates requirements \ref{r:ecore-graphical-display} and \ref{r:ecore-editing}.
    
    \item \textbf{Henshin Rule Creation:} Open the Henshin transformation file, define a transformation rule with an appropriate name (e.g., \texttt{createAccount}), add nodes with action types, connect nodes with edges, add rule parameters, link parameters to node attributes, and save the transformation rule. This step validates requirements \ref{r:henshin-rule-switching}, \ref{r:henshin-graphical-display}, \ref{r:henshin-parameter-editing}, \ref{r:henshin-rule-editing}, \ref{r:henshin-attribute-editing}, and \ref{r:henshin-comment}.
    
    \item \textbf{Instance Model Creation:} Open the \ac{xmi} instance file and add nodes, edges to and set attribute values and save the \ac{xmi} file that the created rule can be applied. This step validates requirements \ref{r:xmi-graphical-display}, \ref{r:xmi-node-editing}, and \ref{r:xmi-attribute-editing}.
    
    \item \textbf{Rule Application:} Verify that the created transformation rule appears in the list of applicable rules, select and apply the transformation rule with appropriate parameter values, and verify that the graphical editor updates to reflect the changes made by the transformation. This step validates requirements \ref{r:xmi-rule-listing} and \ref{r:xmi-rule-application}.
    
    \item \textbf{Verification:} Verify that all created files can be reopened, the graphical editors correctly display all model elements with proper zooming and panning (\ref{r:editor-zoom}), elements can be selected and repositioned with layouts being persisted (\ref{r:nodes-selectable-draggable}), and undo/redo operations work correctly across all editing actions (\ref{r:undo-redo}).
\end{enumerate}

The expected results of the test case are that the test case successfully validated the complete workflow from project creation to rule application. All graphical editors rendered correctly, editing operations were intuitive and responsive, and the transformation rule was successfully applied with the expected results reflected in the instance model. The test confirmed that all relevant functional requirements were properly implemented and integrated, as well as giving judgment of the the non-functional requirements.\\

  \noindent\textbf{Model Synchronization Test: \ac{xmi} Diagram Adaptation After Metamodel Changes}

A critical aspect of maintaining model consistency is ensuring that instance models properly adapt when their underlying metamodel or transformation rules change. This test case validates the system's behavior when Ecore metamodel files or Henshin transformation files are modified while \ac{xmi} instance files are opened in the workspace.

The test objective is to verify that the application correctly handles \ac{xmi} diagram files when changes are made to their corresponding Ecore metamodel or Henshin transformation files.The notation model layouts should be removed and all \ac{xmi} editors should be properly closed to prevent inconsistencies. These are the necessary steps of the test case:

\begin{enumerate}
    \item \textbf{Initial Setup:} Prepare a project with an existing Ecore metamodel file, Henshin transformation rule files, and multiple \ac{xmi} instance files. Open several \ac{xmi} files in the graphical editor, arrange the diagram elements with custom layouts, and verify that the custom layouts are saved in the corresponding notation files.
    
    \item \textbf{Metamodel Modification:} Open the Ecore file in the graphical editor, make structural changes such as adding new attributes, renaming classes, modifying relationships, or changing data types, save the modified Ecore file, and observe the behavior of open \ac{xmi} editors.
    
    \item \textbf{Verify \ac{xmi} Editor Closure:} Confirm that all open \ac{xmi} diagram editors are automatically closed, check that the application displays appropriate notifications or warnings about the closure, and ensure that no \ac{xmi} editors remain open with potentially inconsistent views.
    
    \item \textbf{Verify Notation Deletion:} Navigate to the project file structure in the explorer, verify that all notation files associated with the \ac{xmi} instance files have been reset.
    
    \item \textbf{Reopen and Verify Reset:} Reopen one of the \ac{xmi} files in the graphical editor, verify that the diagram displays with a default automatic layout instead of the previously saved custom layout, confirm that all model elements are still present and correct, and check that the editing options work with the updated metamodel structure.
    
    \item \textbf{Henshin Rule Modification:} Open multiple \ac{xmi} files again and create custom layouts, save the layouts to updete the notation files, modify the Henshin transformation rule file (e.g., add or remove rule parameters, modify node actions), save the Henshin file, and verify that the same automatic closure and notation deletion behavior occurs.
\end{enumerate}

The expected results of the test case are that the test case successfully validates the model synchronization mechanism. When either the Ecore metamodel or Henshin transformation files are modified and saved, all open \ac{xmi} diagram editors get automatically closed to prevent users from working with potentially inconsistent views. All associated notation files are reset, ensuring that layout information would not cause conflicts when the diagrams were reopened. The \ac{xmi} data files themselves remained intact, preserving the instance data. Upon reopening the \ac{xmi} files, the diagrams displayed with fresh automatic layouts appropriate for the updated metamodel structure.\\

\noindent\textbf{Eclipse \ac{ide} Compatibility Test: Interoperability Validation}

A fundamental requirement for the Henshin Web application is seamless interoperability with the existing Henshin Eclipse \ac{ide} ecosystem. This test case validates that projects created in the Eclipse \ac{ide} can be imported into the web application, edited, and then exported back to Eclipse without loss of functionality or compatibility issues.

The test objective is to verify bidirectional compatibility between the Henshin Web application and the Eclipse IDE Henshin plugin, ensuring that users can seamlessly transition between both environments and that file formats remain fully compatible. These are the necessary steps of the test case:

\begin{enumerate}
    \item \textbf{Eclipse Project Creation:} Create a Henshin project in Eclipse \ac{ide} with the Henshin plugin installed, define an Ecore metamodel with multiple classes, attributes, and relationships, create several Henshin transformation rules with various features (parameters, action types, edge conditions, attribute conditions), create multiple \ac{xmi} instance files conforming to the metamodel, apply transformation rules in Eclipse to verify functionality, and export the complete project folder. In the project folder should be one Ecore file, one Henshin file, and any number of \ac{xmi} files.
    
    \item \textbf{Project Upload to Web Application:} Access the Henshin Web application in a browser, use the file upload functionality to upload the entire project folder structure, verify that all files are successfully uploaded and appear in the file explorer, and check that the project structure is preserved (folder hierarchy, file names, file associations). This step validates requirement \ref{r:project-manage} for project import capabilities.
    
    \item \textbf{Ecore Metamodel Verification:} Open the Ecore metamodel file in the web-based graphical editor, verify that all EClass nodes are displayed correctly with proper names and attributes, confirm that all EReference edges are rendered with correct cardinalities and relationship types, check that data types are accurately represented, validate that inheritance relationships and containment hierarchies are preserved, and compare the visual representation with the Eclipse version to ensure consistency. This step validates requirement \ref{r:ecore-graphical-display}.
    
    \item \textbf{Henshin Rule Verification:} Open the Henshin transformation file in the web-based graphical editor, verify that all transformation rules are listed and can be switched between, confirm that nodes, edges, and action types are correctly displayed for each rule, validate that rule parameters are shown with correct names and types, check that attribute conditions and parameter bindings are properly represented, verify that edge multiplicity constraints and node type mappings are accurate, and compare complex rule structures with the Eclipse version. This step validates requirements \ref{r:henshin-rule-switching}, \ref{r:henshin-graphical-display}.
    
    \item \textbf{\ac{xmi} Instance Verification:} Open each \ac{xmi} instance file in the web-based graphical editor, verify that all instance nodes and their relationships are correctly displayed, check that attribute values match those created in Eclipse, confirm that the model conforms to the metamodel structure, and validate that the list of applicable transformation rules is displayed correctly. This step validates requirements \ref{r:xmi-graphical-display} and \ref{r:xmi-rule-listing}.
    
    \item \textbf{Web-Based Modifications:} Make comprehensive changes to all file types including adding new EClass elements with attributes and EReferences to the Ecore metamodel, creating new transformation rules and modifying existing rules in the Henshin file by adding nodes and edges, changing action types, and updating rule parameters, and adding new instance nodes, modifying attribute values, creating new relationships, and applying transformation rules to \ac{xmi} files. Save all modified files and verify that changes are persisted correctly in the web application. This step validates the requirements \ref{r:ecore-editing}, \ref{r:henshin-rule-editing}, \ref{r:henshin-parameter-editing}, \ref{r:henshin-attribute-editing}, \ref{r:xmi-node-editing}, and \ref{r:xmi-attribute-editing}.
    
    \item \textbf{Project Download:} Use the download functionality to export the entire project folder, verify that all files are included in the download, check that file structure and naming conventions are preserved, and ensure that no web-application-specific files are unnecessarily included if they would cause issues. This step validates requirement \ref{r:project-manage}.
    
    \item \textbf{Eclipse Re-import and Verification:} Import the downloaded project into Eclipse \ac{ide} workspace with the Henshin plugin, open and verify the Ecore metamodel file to confirm all modifications made in the web application are visible and correctly represented, open and verify the Henshin transformation file to confirm the new rule and all modifications are correctly displayed with proper rule parameters and attribute bindings, open and verify the \ac{xmi} instance files to confirm all instance modifications are preserved, and apply transformation rules including those modified in the web application to ensure execution compatibility.
    
    \item \textbf{Round-Trip Validation:} Make additional changes in Eclipse, upload the project again to the web application, verify that Eclipse changes are correctly displayed in the web version, and test that the system handles multiple import/export cycles without degradation.
\end{enumerate}

The expected results of the test case are that the test case successfully demonstrated full bidirectional compatibility between the Henshin Web application and the Eclipse IDE Henshin plugin. Projects created in Eclipse were correctly imported into the web application with all model elements, transformation rules, and instance data accurately displayed. All file types maintained their semantic integrity during the import process. Modifications made in the web application were successfully exported and re-imported into Eclipse without any loss of functionality. The Eclipse Henshin plugin correctly interpreted all changes made in the web version, including new metamodel elements, modified transformation rules, and updated instance data. Transformation rules modified in the web application executed correctly when applied in Eclipse, confirming that the underlying \ac{emf} and Henshin data structures remained fully compatible.