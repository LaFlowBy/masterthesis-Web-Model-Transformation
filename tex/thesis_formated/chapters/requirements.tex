  \chapter{Requirements Analysis}
  \label{sec:requirements}

  The purpose of this chapter is to systematically identify, analyze, and document the requirements of the software system developed in the context of this thesis. The chapter outlines functional and non-functional requirements as well as the system stakeholders and constraints.

\section{Stakeholders and User Needs}
  \label{subsec:stakeholders}

  \begin{itemize}
    \item \textbf{Students}: Students who want to learn about \ac{mde} and transformation rules want a very simple and intuitive entry into the topic. Trying out transformations in the browser is a good start, without having to install a lot of software. For students, the core functionality is sufficient, as they only want to try out transformation rules and learn how they work.
    \item \textbf{Researchers}: Researchers, who are researching \ac{mde} and come across Henshin want to be able to test or try out model transformations of Henshin. For researchers, the core functionality could be sufficient, but editing capabilities of the transformation rules and metamodels are practical for them.
    \item \textbf{Software Engineers}: Software engineers who are using \ac{mde} want to be able to test their transformation rules. They want a powerful editor and a collaborative environment to work on their models. For software engineers, the defined additional functionality, as well as some code generation support, are needed to cover their needs.
  \end{itemize}

  The different stakeholders show that the more features the application provides, the more users can be reached. With more features and use cases the application can cover, it provides more value for enterprise users who work for production systems.

  \section{System Scope and Context}
  \label{subsec:system-scope}

  The Eclipse \ac{ide} plugin of Henshin works as a template for the functionality of the application. It provides functionality to create, edit, and apply Henshin transformation rules for Ecore metamodels on \ac{xmi} instances. To create a full enterprise application that will get used for projects in the industry, the application has to also provide very similar functionality.
  The defined core functionality is the minimum set of features that the application must provide to be useful for the users. They are only a subset of requirements to provide a full web-based copy of the Henshin Eclipse plugin.

  \section{Functional Requirements}
  \label{subsec:functional-requirements}

  The main use case that the application should support is that a user can try out transformation rules on \ac{emf} \ac{xmi} instance files. In this use case, the user already has a metamodel and transformation rules. They want to test the transformation rules on various instances in an accessible, intuitive, and easy to use graphical editor. The extended use case is that a user wants to create a full transformation language from scratch, that can be used to model and test the system and generate production code from it. In this use case, the user wants to create and edit metamodels and transformation rules. To support this use case, the following functional requirements are defined:

\subsection{General requirements}

\begin{requirement}
    \label{r:login}
    The application should provide a login functionality to authenticate users and persist their workspace.
\end{requirement}

\begin{requirement}
    \label{r:editor-zoom}
    The application should provide zooming and panning functionality for the graphical editor.
\end{requirement}

\begin{requirement}
    \label{r:nodes-selectable-draggable}
    All graphical elements should be selectable and draggable to create an own layout. That layout should be persisted and restored when reopening the editor.
\end{requirement}

\begin{requirement}
    \label{r:undo-redo}
    The application should provide undo and redo functionality for all editing operations in all editors.
\end{requirement}

\begin{requirement}
    \label{r:project-manage}
    The application should provide functionality to upload, download, create and delete projects and workspaces.
\end{requirement}

  Some of these requirements are already provided by Eclipse Theia and \ac{glsp}. Theia provides various views like the explorer for basic file management, including opening, saving, closing, creating and deleting files, a problems view, an integrated terminal, or edit operations like copy or paste. \ac{glsp} provides default functionality for each graphical editor. That includes selection of elements, moving nodes, realigning edges, zooming, or moving and resetting the viewport. Most of these features can be further configured to be able to create an editor fitting the specific needs.

\subsection{\ac{xmi} editor requirements}

\begin{requirement}
    \label{r:xmi-graphical-display}
    \ac{emf} \ac{xmi} instance files should be displayed in a graphical editor. That contains all nodes, adjacent edges and attributes of the node.
\end{requirement}

\begin{requirement}
    \label{r:xmi-node-editing}
    The \ac{xmi} instance editor should provide editing functionality to create, update and delete nodes and edges.
\end{requirement}

\begin{requirement}
    \label{r:xmi-attribute-editing}
    The \ac{xmi} instance editor should provide editing functionality to set custom values to all attributes.
\end{requirement}

\begin{requirement}
    \label{r:xmi-rule-listing}
    In the \ac{xmi} instance editor all applicable transformation rules should be listed. When a rule is selected to get applied, a window to specify the rule parameters should be opened. After specifying the parameters, the rule can get applied to the \ac{xmi} instance.
\end{requirement}

\begin{requirement}
    \label{r:xmi-rule-application}
    When a rule gets applied, the graphical editor of the \ac{xmi} instance should be updated to reflect the changes made by the transformation rule. 
\end{requirement}

\subsection{Henshin editor requirements}

\begin{requirement}
  \label{r:henshin-rule-switching}
  All rules of a \textit{.henshin} file should be listed. The user should be able to switch between all rules. New rules can be created, and existing rules can be deleted.
\end{requirement}

\begin{requirement}
    \label{r:henshin-graphical-display}
    Henshin transformation rule files should be displayed in a graphical editor. That contains the name, parameters, nodes, edges, action types, and attributes of all rules.  
\end{requirement}

\begin{requirement}
    \label{r:henshin-parameter-editing}
    The Henshin editor should provide editing functionality of the rule name, and its parameters.
\end{requirement}

\begin{requirement}
    \label{r:henshin-rule-editing}
    The Henshin editor should provide editing functionality to create, update and delete nodes, edges and action-types of a specific rule.
\end{requirement}

\begin{requirement}
    \label{r:henshin-attribute-editing}
    The Henshin editor should provide editing functionality to connect rule parameters to attributes of a specific rule.
\end{requirement}

\begin{requirement}
    \label{r:henshin-comment}
    The Henshin editor should provide editing functionality to add, edit and delete comments.
\end{requirement}

\subsection{Ecore editor requirements}

\begin{requirement}
    \label{r:ecore-graphical-display}
    \ac{emf} Ecore metamodel should be displayed in a graphical editor. That contains the nodes, edges and attributes of the metamodel.
\end{requirement}

\begin{requirement}
    \label{r:ecore-editing}
    The Ecore editor should provide editing functionality to create, update and delete nodes, edges and attributes.
\end{requirement}

\subsection{ Additional optional Requirements}

The following requirements are additional functionality that can be implemented to provide more value to the users. They are not core functionality, but they extend the use cases of the application.

\begin{requirement}
    \label{r:attributes-expressions}
    Henshin transformation rule attributes can contain JavaScript expressions to compute values.
\end{requirement}

\begin{requirement}
    \label{r:transformation-units}
    Henshin transformation units are also listed in the \ac{xmi} instance editor and can be applied.
\end{requirement}

\begin{requirement}
    \label{r:rule-matches}
    Show the possible transformation rule matches in the \ac{xmi} instance editor, when selecting a transformation rule.
\end{requirement}

\begin{requirement}
    \label{r:state-space-analysis}
    Provide the functionality to apply a State Space analysis on a \ac{xmi} instance.
\end{requirement}

\begin{requirement}
    \label{r:conflict-dependency-analysis}
    Provide the functionality to apply a conflict and dependency analysis on a \ac{xmi} instance. 
\end{requirement}

  There exist many more use cases for model transformations and \ac{mde} in general. The application can grow to a web-based platform for \ac{mde} in the future. Additional functionality will be discussed in section \ref{subsec:suggestions-future-development} but these use cases are not scope of this thesis.

  \section{Non-Functional Requirements}
  \label{subsec:non-functional-requirements}

  In addition to the core functionality, the system must meet several non-functional requirements:

\begin{requirement}
    \label{r:web-based-access}
    The application should be web-based and preferably accessible via a web browser.
\end{requirement}

\begin{requirement}
    \label{r:accessibility}
    The application should be accessible without the need to install additional software, except for a web browser.
\end{requirement}

\begin{requirement}
    \label{r:responsive-design}
    The application should be responsive and work on different screen sizes. It does not have to support mobile devices and touch interactions, since \ac{glsp} is also not supporting touch interactions \cite{glsp-repo}.
\end{requirement}

\begin{requirement}
    \label{r:user-friendly-interface}
    The application should be user-friendly and intuitive to use. For that, the application should follow the design principles of \ac{glsp} and Eclipse Theia. That includes the use of views of theia, like the explorer and the predefined \ac{ui} controls of \ac{glsp}, like the tool palette or the context menu.
\end{requirement}

\begin{requirement}
    \label{r:extendable-architecture}
    The application should have an extendable architecture that allows for easy integration of new features and functionalities.
\end{requirement}

\begin{requirement}
    \label{r:portable-integration}
    The application should be portable and easy to integrate into other \ac{glsp} integration options.
\end{requirement}

  \section{System Constraints}
  \label{subsec:system-constraints}

  One constraint is the use of Henshin as a model transformation language. Henshin is a Java-based framework, which means that the application needs a possibility to run Java code in the backend. The easiest way for that is to use a Java-based backend, that can directly use the Henshin SDK code.
  The use of Henshin also brings the constraint that, metamodels and instances are based on \ac{emf}.

  Another constraint is the use of web-based technologies and preferably a resulting web application. For model transformations, there exist many applications, but not many of them are web-based. This constraint is also a non functional requirement and was also motivated in previous sections.
  The initial version of the application will support English only.