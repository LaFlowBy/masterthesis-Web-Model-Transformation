\chapter{Testing and Evaluation}
  \label{sec:testing}

  This chapter discusses the testing strategy of the Henshin Web application. First the general strategy is described. Then the structure and results of the unit tests and end-to-end tests are seperatly presented. Finally, the limitations of the testing are discussed.

  
  \section{Testing Strategy}
  \label{subsec:testing-strategy}


The Henshin Web Model Transformation project employs a comprehensive multi-layered testing strategy to ensure reliability and correctness across both backend and frontend components. For the Java backend, unit tests were implemented using JUnit 5 framework in conjunction with Mockito for mocking dependencies. Throughout the development process, tests were incrementally added for each milestone to ensure that newly implemented functionality works as expected and does not break existing features. The test suite covers the core functionality of the backend, including model operations, rule transformations, and handler implementations. Mocking was extensively used to simulate the behavior of complex components such as the ModelState, EditingDomain, and various EMF resources, allowing for isolated testing of individual components without dependencies on external systems.

To test the user interface and end-to-end functionality, automated UI tests were created using Playwright framework. This choice was made after evaluating several alternatives including Cypress and Selenium, with Playwright being selected for its robust support of Theia applications through the specialized @theia/playwright testing library. The testing strategy ensures both individual component reliability through unit testing and complete system functionality through comprehensive end-to-end testing scenarios.

  \section{Unit Tests}
  \label{subsec:test-results}


The backend unit testing suite comprises 46 individual test files covering all critical components of the GLSP server implementation. The tests are organized into several key areas: base functionality tests verify core constants and utility classes like HenshinTypesTest, model layer tests ensure proper functioning of components such as RuleModelIndex and various factory classes, handler tests validate the correct behavior of operation handlers for actions like rule updates and model modifications, and XMI processing tests confirm proper handling of model transformations and rule applications.

The unit tests employ sophisticated mocking strategies using Mockito to isolate components under test. For instance, the RuleModelIndexTest uses mock EObject instances and EMFSemanticIdConverter to test model indexing functionality without requiring actual EMF resources. Similarly, handler tests like UpdateRuleOperationHandlerTest mock complex dependencies such as RuleModelState and ActionDispatcher while using real Henshin test resources for integration-style testing. A dedicated TestHelper class provides standardized test resource management, loading consistent test models including bank.ecore, bank-instance.xmi, and bank.henshin files across all test cases.

The tests maintain high coverage of critical paths including error handling, edge cases, and boundary conditions. For example, tests verify proper exception handling when resources cannot be loaded, validate parameter mapping functionality with empty and populated data sets, and ensure correct behavior when operating on invalid or missing model elements. The use of JUnit 5's advanced features such as parameterized tests and conditional test execution allows for comprehensive validation across different scenarios and configurations.

  \section{E2E Tests}
  \label{subsec:performance-evaluation}

For end-to-end testing, different frameworks were initially considered including Cypress, Playwright, Selenium, and several others. After careful evaluation considering factors such as Theia application support, test reliability, debugging capabilities, and maintenance overhead, Playwright was selected as the optimal choice. The decision was further reinforced by the availability of the specialized @theia/playwright library, which provides native support for testing Theia-based applications with built-in helpers for common operations and better handling of Theia's asynchronous loading behavior.

The E2E test suite encompasses three main test files covering distinct aspects of the application: app.spec.ts validates basic application loading and ensures the main content panel is visible after startup, explorer.spec.ts tests the file explorer functionality including navigation, file selection, and workspace operations, and xmi.spec.ts provides comprehensive testing of the GLSP diagram editor including XMI file opening, diagram element rendering, user interactions, and context menu operations. The tests are configured with extended timeouts to accommodate the complex loading sequences of GLSP editors and include comprehensive error handling with screenshot capture and video recording for failed test scenarios.

The E2E tests simulate realistic user workflows such as opening the bank example workspace, navigating to XMI files, launching the GLSP diagram editor, interacting with diagram elements, and validating that model transformations are properly reflected in the visual representation. The test configuration supports multiple browsers including Chromium and Firefox, ensuring cross-browser compatibility. Advanced features such as trace collection on retry, automatic screenshot capture on failure, and video recording provide comprehensive debugging information when tests fail, significantly reducing the time required to diagnose and fix issues.

  \section{Limitations}
  \label{subsec:user-feedback}

  While the testing strategy provides comprehensive coverage, several limitations were identified during implementation and execution. The E2E tests are inherently dependent on the complete application stack being operational, including the Theia frontend, GLSP server, and all associated services, making them more fragile and slower to execute than unit tests. The complex asynchronous nature of GLSP editors occasionally leads to timing-related test failures, particularly in CI environments with limited resources, requiring careful timeout management and retry logic.

The unit test mocking strategy, while effective for isolation, sometimes masks integration issues that only surface when components interact with real EMF resources and editing domains. Some complex model transformation scenarios are difficult to test in isolation and require comprehensive integration tests that bridge the gap between unit and E2E testing. Additionally, the current test suite has limited coverage of performance scenarios and stress testing, focusing primarily on functional correctness rather than system behavior under load.

The testing infrastructure requires significant setup and maintenance overhead, particularly for the E2E tests which depend on specific versions of browsers, the Theia framework, and associated testing libraries. Browser compatibility testing is limited to Chromium and Firefox, potentially missing issues specific to other browser engines. Finally, while the test suite provides good coverage of happy path scenarios and common error cases, coverage of edge cases involving malformed models or unusual user interaction patterns could be expanded to further improve system robustness.
