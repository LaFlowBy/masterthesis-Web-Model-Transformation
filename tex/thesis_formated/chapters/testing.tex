\chapter{Testing and Evaluation}
  \label{sec:testing}

  This chapter discusses the testing strategy of the Henshin Web application. First the general strategy is described. Then the structure and results of the unit tests and end-to-end tests are seperatly presented. Finally, the limitations of the testing are discussed.

  
  \section{Testing Strategy}
  \label{subsec:testing-strategy}


The Henshin Web Model Transformation project employs a multi-layered testing strategy to ensure reliability and correctness across both backend and frontend components. For the Java backend, unit tests were implemented using JUnit 5 framework in conjunction with Mockito for mocking dependencies. Throughout the development process, tests were incrementally added for each milestone to ensure that newly implemented functionality works as expected and does not break existing features. The test suite covers the core functionality of the backend, including model operations, rule transformations, and handler implementations. Mocking was extensively used to simulate the behavior of complex components such as the ModelState, EditingDomain, and various EMF resources, allowing for isolated testing of individual components without dependencies on external systems.

To test the user interface and end-to-end functionality, automated UI tests were created using Playwright framework. This choice was made after evaluating several alternatives including Cypress and Selenium, with Playwright being selected for its robust support of Theia applications through the specialized @theia/playwright testing library. The testing strategy ensures both individual component reliability through unit testing and complete system functionality through comprehensive end-to-end testing scenarios.

  \section{Unit Tests}
  \label{subsec:test-results}


The backend unit testing suite comprises 46 individual test files covering all critical components of the GLSP server implementation. The tests are organized into several key areas: base functionality tests verify core constants and utility classes like HenshinTypesTest, model layer tests ensure proper functioning of components such as RuleModelIndex and various factory classes, handler tests validate the correct behavior of operation handlers for actions like rule updates and model modifications, and \ac{xmi} processing tests confirm proper handling of model transformations and rule applications.

The unit tests employ sophisticated mocking strategies using Mockito to isolate components under test. For instance, the RuleModelIndexTest uses mock EObject instances and EMFSemanticIdConverter to test model indexing functionality without requiring actual EMF resources. Similarly, handler tests like UpdateRuleOperationHandlerTest mock complex dependencies such as RuleModelState and ActionDispatcher while using real Henshin test resources for integration-style testing. A dedicated TestHelper class provides standardized test resource management, loading consistent test models including bank.ecore, bank-instance.xmi, and bank.henshin files across all test cases.

The tests maintain high coverage of critical paths including error handling, edge cases, and boundary conditions. For example, tests verify proper exception handling when resources cannot be loaded, validate parameter mapping functionality with empty and populated data sets, and ensure correct behavior when operating on invalid or missing model elements. The use of JUnit 5's advanced features such as parameterized tests and conditional test execution allows for comprehensive validation across different scenarios and configurations.

  \section{E2E Tests}
  \label{subsec:performance-evaluation}

For end-to-end testing, different frameworks were initially considered including Cypress, Playwright, Selenium, and several others. After careful evaluation considering factors such as Theia application support, test reliability, debugging capabilities, and maintenance overhead, Playwright was selected as the optimal choice. The decision was further reinforced by the availability of the specialized @theia/playwright library, which provides native support for testing Theia-based applications with built-in helpers for common operations and better handling of Theia's asynchronous loading behavior.

The E2E test suite encompasses three main test files covering distinct aspects of the application: app.spec.ts validates basic application loading and ensures the main content panel is visible after startup, explorer.spec.ts tests the file explorer functionality including navigation, file selection, and workspace operations, and xmi.spec.ts provides comprehensive testing of the GLSP diagram editor including \ac{xmi} file opening, diagram element rendering, user interactions, and context menu operations. The tests are configured with extended timeouts to accommodate the complex loading sequences of GLSP editors and include comprehensive error handling with screenshot capture and video recording for failed test scenarios.

The E2E tests simulate realistic user workflows such as opening the bank example workspace, navigating to \ac{xmi} files, launching the GLSP diagram editor, interacting with diagram elements, and validating that model transformations are properly reflected in the visual representation. The test configuration supports multiple browsers including Chromium and Firefox, ensuring cross-browser compatibility. Advanced features such as trace collection on retry, automatic screenshot capture on failure, and video recording provide comprehensive debugging information when tests fail, significantly reducing the time required to diagnose and fix issues.

  \section{Manual Test Cases}
  \label{subsec:test-cases}

To complement the automated test suite and validate real-world usage scenarios, a series of manual test cases were executed throughout the development process. These test cases focused on user workflows that are difficult to automate or require human judgment to evaluate, such as visual appearance, performance perception, and overall usability. The following subsections describe key manual test cases that validate the end-to-end functionality of the application.

  \subsection{Complete Workflow Test: Project Creation to Rule Application}
  \label{subsubsec:complete-workflow-test}

One of the most comprehensive manual test case involved creating a complete project from scratch and testing the entire transformation workflow. This test case validates the integration of all major components of the system and ensures that the requirements for metamodel editing, transformation rule creation, and rule application are properly implemented.

\textbf{Test Objective:} Verify that a user can create a complete Henshin transformation project from scratch, including metamodel definition, transformation rule creation, instance model creation, and successful rule application. These are the necessary test steps:

\begin{enumerate}
    \item \textbf{Project Creation:} Create a new project folder in the application using the file explorer functionality. This validates requirement \ref{r:project-manage}.

    \item \textbf{Metamodel Creation:} Open the Ecore metamodel file and create multiple EClass nodes, references and attributes (e.g., a simple banking domain with \texttt{Account} and \texttt{Customer} classes), set appropriate data types for attributes, and save the metamodel file. This step validates requirements \ref{r:ecore-graphical-display} and \ref{r:ecore-editing} for metamodel visualization and editing.
    
    \item \textbf{Henshin Rule Creation:} Open the Henshin transformation file, define a transformation rule with an appropriate name (e.g., \texttt{createAccount}), add nodes with action types, connect nodes with edges, add rule parameters for dynamic values, link parameters to node attributes, and save the transformation rule. This validates requirements \ref{r:henshin-rule-switching}, \ref{r:henshin-graphical-display}, \ref{r:henshin-parameter-editing}, \ref{r:henshin-rule-editing}, \ref{r:henshin-attribute-editing}, and \ref{r:henshin-comment} for rule creation and editing.
    
    \item \textbf{Instance Model Creation:} Open the \ac{xmi} instance file and add nodes, edges to and set attribute values and save the \ac{xmi} file that the created rule can be applied. This validates requirements \ref{r:xmi-graphical-display}, \ref{r:xmi-node-editing}, and \ref{r:xmi-attribute-editing} for instance model manipulation.
    
    \item \textbf{Rule Application:} Verify that the created transformation rule appears in the list of applicable rules, select and apply the transformation rule with appropriate parameter values, and verify that the graphical editor updates to reflect the changes made by the transformation. This validates requirements \ref{r:xmi-rule-listing} and \ref{r:xmi-rule-application} for rule discovery, parameter specification, and transformation execution.
    
    \item \textbf{Verification:} Verify that all created files can be reopened, the graphical editors correctly display all model elements with proper zooming and panning (\ref{r:editor-zoom}), elements can be selected and repositioned with layouts being persisted (\ref{r:nodes-selectable-draggable}), and undo/redo operations work correctly across all editing actions (\ref{r:undo-redo}).
\end{enumerate}

\textbf{Expected Results:} The test case successfully validated the complete workflow from project creation to rule application. All graphical editors rendered correctly, editing operations were intuitive and responsive, and the transformation rule was successfully applied with the expected results reflected in the instance model. The test confirmed that all relevant functional requirements were properly implemented and integrated.

  \subsection{Model Synchronization Test: \ac{xmi} Diagram Adaptation After Metamodel Changes}
  \label{subsubsec:model-synchronization-test}

A critical aspect of maintaining model consistency is ensuring that instance models properly adapt when their underlying metamodel or transformation rules change. This test case validates the system's behavior when Ecore metamodel files or Henshin transformation files are modified while \ac{xmi} instance files exist in the workspace.

\textbf{Test Objective:} Verify that the application correctly handles \ac{xmi} diagram files when changes are made to their corresponding Ecore metamodel or Henshin transformation files, ensuring that stale notation layouts are removed and editors are properly closed to prevent inconsistencies. These are the necessary test steps:

\begin{enumerate}
    \item \textbf{Initial Setup:} Prepare a project with an existing Ecore metamodel file, Henshin transformation rule files, and multiple \ac{xmi} instance files. Open several \ac{xmi} files in the graphical editor, arrange the diagram elements with custom layouts, and verify that the custom layouts are saved in the corresponding notation files.
    
    \item \textbf{Metamodel Modification:} Open the Ecore file in the graphical editor, make structural changes such as adding new attributes, renaming classes, modifying relationships, or changing data types, save the modified Ecore file, and observe the behavior of open \ac{xmi} editors.
    
    \item \textbf{Verify \ac{xmi} Editor Closure:} Confirm that all open \ac{xmi} diagram editors are automatically closed, check that the application displays appropriate notifications or warnings about the closure, and ensure that no \ac{xmi} editors remain open with potentially inconsistent views.
    
    \item \textbf{Verify Notation Deletion:} Navigate to the project file structure in the explorer, verify that all notation files associated with the \ac{xmi} instance files have been deleted, and confirm that the \ac{xmi} files themselves remain intact.
    
    \item \textbf{Reopen and Verify Reset:} Reopen one of the \ac{xmi} files in the graphical editor, verify that the diagram displays with a default automatic layout instead of the previously saved custom layout, confirm that all model elements are still present and correct, and check that the editor functions normally with the updated metamodel structure.
    
    \item \textbf{Henshin Rule Modification:} Open multiple \ac{xmi} files again and create custom layouts, save the layouts to generate new notation files, modify the Henshin transformation rule file (e.g., add or remove rule parameters, modify node actions), save the Henshin file, and verify that the same automatic closure and notation deletion behavior occurs.
\end{enumerate}

\textbf{Expected Results:} The test case successfully validated the model synchronization mechanism. When either the Ecore metamodel or Henshin transformation files were modified and saved, all open \ac{xmi} diagram editors were automatically closed to prevent users from working with potentially inconsistent views. All associated notation files were deleted, ensuring that stale layout information would not cause conflicts when the diagrams were reopened. The \ac{xmi} data files themselves remained intact, preserving the instance data. Upon reopening the \ac{xmi} files, the diagrams displayed with fresh automatic layouts appropriate for the updated metamodel structure.

  \subsection{Eclipse \acs{ide} Compatibility Test: Interoperability Validation}
  \label{subsubsec:eclipse-compatibility-test}

A fundamental requirement for the Henshin Web application is seamless interoperability with the existing Henshin Eclipse \ac{ide} ecosystem. This test case validates that projects created in the Eclipse \ac{ide} can be imported into the web application, edited, and then exported back to Eclipse without loss of functionality or compatibility issues.

\textbf{Test Objective:} Verify bidirectional compatibility between the Henshin Web application and the Eclipse IDE Henshin plugin, ensuring that users can seamlessly transition between both environments and that file formats remain fully compatible.

\textbf{Test Steps:}

\begin{enumerate}
    \item \textbf{Eclipse Project Creation:} Create a Henshin project in Eclipse \ac{ide} with the Henshin plugin installed, define an Ecore metamodel with multiple classes, attributes, and relationships, create several Henshin transformation rules with various features (parameters, action types, edge conditions, attribute conditions), create multiple \ac{xmi} instance files conforming to the metamodel, apply transformation rules in Eclipse to verify functionality, and export the complete project folder. In the project folder should be one Ecore file, one Henshin file, and any number of \ac{xmi} files.
    
    \item \textbf{Project Upload to Web Application:} Access the Henshin Web application in a browser, use the file upload functionality to upload the entire project folder structure, verify that all files are successfully uploaded and appear in the file explorer, and check that the project structure is preserved (folder hierarchy, file names, file associations). This step validates requirement \ref{r:project-manage} for project import capabilities.
    
    \item \textbf{Ecore Metamodel Verification:} Open the Ecore metamodel file in the web-based graphical editor, verify that all EClass nodes are displayed correctly with proper names and attributes, confirm that all EReference edges are rendered with correct cardinalities and relationship types, check that data types are accurately represented, validate that inheritance relationships and containment hierarchies are preserved, and compare the visual representation with the Eclipse version to ensure consistency. This validates requirement \ref{r:ecore-graphical-display} for accurate metamodel visualization.
    
    \item \textbf{Henshin Rule Verification:} Open the Henshin transformation file in the web-based graphical editor, verify that all transformation rules are listed and can be switched between, confirm that nodes, edges, and action types are correctly displayed for each rule, validate that rule parameters are shown with correct names and types, check that attribute conditions and parameter bindings are properly represented, verify that edge multiplicity constraints and node type mappings are accurate, and compare complex rule structures with the Eclipse version. This validates requirements \ref{r:henshin-rule-switching}, \ref{r:henshin-graphical-display}, and related Henshin editing requirements.
    
    \item \textbf{\ac{xmi} Instance Verification:} Open each \ac{xmi} instance file in the web-based graphical editor, verify that all instance nodes and their relationships are correctly displayed, check that attribute values match those created in Eclipse, confirm that the model conforms to the metamodel structure, and validate that the list of applicable transformation rules is displayed correctly. This validates requirements \ref{r:xmi-graphical-display} and \ref{r:xmi-rule-listing}.
    
    \item \textbf{Web-Based Modifications:} Make comprehensive changes to all file types including adding new EClass elements with attributes and EReferences to the Ecore metamodel, creating new transformation rules and modifying existing rules in the Henshin file by adding nodes and edges, changing action types, and updating rule parameters, and adding new instance nodes, modifying attribute values, creating new relationships, and applying transformation rules to \ac{xmi} files. Save all modified files and verify that changes are persisted correctly in the web application. This validates the complete editing capabilities across requirements \ref{r:ecore-editing}, \ref{r:henshin-rule-editing}, \ref{r:henshin-parameter-editing}, \ref{r:henshin-attribute-editing}, \ref{r:xmi-node-editing}, and \ref{r:xmi-attribute-editing}.
    
    \item \textbf{Project Download:} Use the download functionality to export the entire project folder, verify that all files are included in the download, check that file structure and naming conventions are preserved, and ensure that no web-application-specific files are unnecessarily included if they would cause issues. This validates requirement \ref{r:project-manage} for project export capabilities.
    
    \item \textbf{Eclipse Re-import and Verification:} Import the downloaded project into Eclipse \ac{ide} workspace with the Henshin plugin, open and verify the Ecore metamodel file to confirm all modifications made in the web application are visible and correctly represented, open and verify the Henshin transformation file to confirm the new rule and all modifications are correctly displayed with proper rule parameters and attribute bindings, open and verify the \ac{xmi} instance files to confirm all instance modifications are preserved, and apply transformation rules including those modified in the web application to ensure execution compatibility.
    
    \item \textbf{Round-Trip Validation:} Make additional changes in Eclipse, upload the project again to the web application, verify that Eclipse changes are correctly displayed in the web version, and test that the system handles multiple import/export cycles without degradation.
\end{enumerate}

\textbf{Expected Results:} The test case successfully demonstrated full bidirectional compatibility between the Henshin Web application and the Eclipse IDE Henshin plugin. Projects created in Eclipse were correctly imported into the web application with all model elements, transformation rules, and instance data accurately displayed. All file types maintained their semantic integrity during the import process. Modifications made in the web application were successfully exported and re-imported into Eclipse without any loss of functionality. The Eclipse Henshin plugin correctly interpreted all changes made in the web version, including new metamodel elements, modified transformation rules, and updated instance data. Transformation rules modified in the web application executed correctly when applied in Eclipse, confirming that the underlying \ac{emf} and Henshin data structures remained fully compatible.


  \section{Limitations}
  \label{subsec:user-feedback}

  While the testing strategy provides comprehensive coverage, several limitations were identified during implementation and execution. The E2E tests are inherently dependent on the complete application stack being operational, including the Theia frontend, GLSP server, and all associated services, making them more fragile and slower to execute than unit tests. The complex asynchronous nature of GLSP editors occasionally leads to timing-related test failures, particularly in CI environments with limited resources, requiring careful timeout management and retry logic.

The unit test mocking strategy, while effective for isolation, sometimes masks integration issues that only surface when components interact with real EMF resources and editing domains. Some complex model transformation scenarios are difficult to test in isolation and require comprehensive integration tests that bridge the gap between unit and E2E testing. Additionally, the current test suite has limited coverage of performance scenarios and stress testing, focusing primarily on functional correctness rather than system behavior under load.

The testing infrastructure requires significant setup and maintenance overhead, particularly for the E2E tests which depend on specific versions of browsers, the Theia framework, and associated testing libraries. Browser compatibility testing is limited to Chromium and Firefox, potentially missing issues specific to other browser engines. Finally, while the test suite provides good coverage of happy path scenarios and common error cases, coverage of edge cases involving malformed models or unusual user interaction patterns could be expanded to further improve system robustness.
