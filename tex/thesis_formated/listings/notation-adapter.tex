\begin{lstlisting}[language=Java, caption={Parts of \code{NotationAdapter}}, label={lst:notation-adapter}]
public class NotationAdapter extends AdapterImpl {
    private Shape shape;

    public NotationAdapter(Shape shape) {
        this.shape = shape;
    }

    @Override
    public boolean isAdapterForType(Object type) {
        return type == NotationAdapter.class;
    }

    public static Shape getOrAssignNotation(DynamicEObjectImpl obj) {
        // Return existing Notation if present
        for (var adapter : obj.eAdapters()) {
            if (adapter instanceof NotationAdapter) {
                return ((NotationAdapter) adapter).getShape();
            }
        }

        // Assign new Notation
        String hashId = hashENodeObject(obj);
        Shape shape = notationMap.get(hashId);
        if(shape == null) {
            shape = XMINotationFactory.createNewShape(obj);
        }
        NotationAdapter newAdapter = new NotationAdapter(shape);
        obj.eAdapters().add(newAdapter);

        return shape;
    }

    public static String hashENodeObject(DynamicEObjectImpl eObject) {
        StringBuilder result = new StringBuilder();

        result.append(eObject.eClass().getName()).append(":");
        result.append(DynamicEObjectImpl.class.getSimpleName());

        for (EStructuralFeature feature : eObject.eClass().getEAllStructuralFeatures()) {
            if (feature instanceof EAttribute) {
                result.append("-").append(feature.getName());
                result.append(":").append(feature.getEType().getName());
                result.append("=").append(eObject.eGet(feature).toString());
            }
        }

        return result.toString();
    }

    public static void dispose() {
        notationMap.clear();
    }
}
\end{lstlisting}