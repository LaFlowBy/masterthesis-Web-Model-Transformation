\section{Implementation}
  \label{subsec:implementation}
  This chapter describes and shows the solution and implementation of specific problems, that appeared while implementing a \ac{poc} to display \ac{xmi} instances and apply model transformation rules on them. The main problems with the \ac{poc} were the integration of Henshin into a \ac{glsp} project, the layout of the graphical model, and the indexing of \ac{emf} model elements. The \acs{gui} of the \ac{poc} can be seen in figure \ref{fig:poc}.

  \subsection{Integration of Henshin into a GLSP project} 
  \label{subsec:henshin-glsp}

  The Henshin source code provides both the Eclipse \ac{ide} plugin and a Java SDK for using the Henshin interpreter. The project is structured as an Eclipse project and is available as a set of Eclipse plugins and features. \cite{henshin-repo} On the other hand, \ac{glsp} projects typically use a Maven project structure. \cite{glsp-repo} To add dependencies to a Maven project, the dependencies should ideally be available as Maven artifacts. However, Henshin doesn't provide a Maven artifact, since that is not needed for an Eclipse plugin. The Henshin version 1.8.0 is compatible with \acs{jdk} 11 and higher. \ac{glsp} version 2.3.0 has the prerequisite of \acs{jdk} 17. Therefore, the versions are compatible to run together. The Henshin code consists of 45 plugins, of which 22 are contained in the Henshin SDK, that we need as a dependency in our Henshin Web \ac{glsp} project. Each plugin can be downloaded as a \acs{jar} file. To create Maven packages from the \acsp{jar}, a PowerShell script is used. It reads all \acsp{jar} files from a folder, renames them to the correct Maven artifact name, creates a basic \code{pom.xml} file for them, deploys them to the GitLab package repository, and creates a list that needs to be included in the Maven \code{pom.xml} file of the \ac{glsp} project. To provide the Henshin dependencies to anyone, the packages are stored in the Giblab package registry of the Henshin Web GitLab repository. A package of each plugin is created, because for the Henshin Web editor, only some parts of the Henshin SDK are needed. To use the Henshin model package, the additional dependency of the Nashorn JavaScript engine \cite{nashorn-repo} is needed. The Nashorn engine is used to execute calculation expressions of transformation rules. \cite{henshin}

  \subsection{Layouting}
  \label{subsec:layouting}

  \ac{emf} Ecore metamodel files (\textit{.ecore}), Henshin rule files (\textit{.henshin}) and \ac{emf} instance files (\textit{.xmi}), don't contain information about the position or size of elements in a graph. \cite{emf,henshin-repo} To provide a good user experience, the graphical editors need to provide a consistent macro layout of nodes and edges. Newly created nodes should not overlap with existing nodes, and the nodes should stay in the same place after reloading the editor. In general, the \ac{glsp} server is responsible for the macro layouting. \cite{glsp-doc} \ac{glsp} provides multiple options to layout the graph. The interface \code{LayoutEngine} can be used to create a custom layout algorithm, that is applied after the creation of the graphical model from the source model. \ac{glsp} provides the \code{ElkLayoutEngine} implementation, that uses the \ac{elk} to layout the graphical model. \cite{elk-engine} With \ac{elk}, different layout algorithms can be used and additionally configured. Even though \ac{elk} provides much flexibility for the layout, the layout is newly created after every change to the source model. This means that the layout is not consistent and nodes can move around after every change. To provide a consistent layout, the position of nodes need to be stored in addition to the source model. The \ac{glsp} server provides a notation model, that can be used to store the position and size of nodes and edges. \cite{glsp-repo} This brings the overhead of updating the notation model every time when the source model is updated. \ac{glsp} provides classes to make the synchronization of the notation model easier. The notation model is stored in an additional \textit{.notation} file, that is loaded together with the source model and applied to the graphical model in the \code{GModelFactory} when using the \code{NotationUtil.applyShapeData(shape, builder)} method. To capture changes of position and size of nodes, the \ac{glsp} client sends the \code{ChangeRoutingPointsOperation} and \code{ChangeBoundsOperation} operations automatically when moving or resizing a node or edge. At the server, the corresponding handlers are updating the notation model using commands to provide undo and redo functionalities.

  To achieve layouting in the Henshin Web editor, notation models for the metamodel, Henshin rules, and instances are used. For the \ac{xmi} instance models, layouting over the notation models is implemented in the \acs{poc}. The \textit{.notation} file is created when the instance model is loaded for the first time. Here, \ac{elk} can be used to create a fitting initial layout. When creating the graphical model in the \code{GModelFactory}, the shape data from the notation model is added to the \ac{emf} elements over an \ac{emf} \code{Adapter}. Each \ac{emf} \code{EObject} has a list of adapters, that can be used to store additional information. \cite{emf} To connect the notation to an element, the \code{NotationAdapter.getOrAssignNotation()} method checks if the element already has a notation, either returning the existing notation or appending a new Adapter with the notation information.

  \subsection{Indexing EMF models}
  \label{subsec:indexing}

  Next to layout information, \ac{emf} Ecore metamodels and \ac{emf} \ac{xmi} instance models don't by default contain unique identifiers for nodes, edges, or attributes. \cite{emf,emf-repo} 
  During the transformation of the source model into the graphical model, elements need to be accessed multiple times. For example, a node is accessed from the \ac{emf} package when it is mapped into a \code{GNode} and then again for all its connected edges and attributes. To avoid multiple lookups in the \ac{emf} model, an index is created for each node, edge, or attribute. Additionally, the graphical model of \ac{glsp} needs identifiers for each element, to be able to specify the element for operations on the source model. When no identifiers are specified, \ac{glsp} generates its own unique identifiers for each element, but they cannot be mapped back to the corresponding \ac{emf} element. To keep a unique identifier close to the \ac{emf} element, an \ac{emf} \code{Adapter} is used. 

  For adding indexes to the graphical model elements, random \acp{uuid} can be used. The same identifiers can be held for the lifetime of the corresponding client session. During this time, operations on the source model can access \ac{emf} elements by their \acp{uuid} over a \code{HashMap} and then apply the operation. The use of content-independent identifiers has the advantage, that the identifiers are not changing when nodes are updated. The problem with temporary identifiers on the other hand is, that they cannot be mapped to the source elements after the client session is closed. One use case for that are the notation models, where the \acp{uuid} cannot be used, because the same notation model needs to be loaded across client sessions. To achieve a session-independent solution to connect the notation model's elements to the \ac{emf} elements, content hashes are used as identifiers. Each node in the source model is identifiable by the class name and its combined attribute values. These content hashes are stored in the notation model and generated every time the graphical model is created for the first time in a session. The combination of the \acp{uuid} and content hashes allows flexibility for editing the source model, while maintaining the connection to the notation model.

  \subsection{Development Process}
  \label{subsec:development-process}

  \subsection{Key Features and Functionality}
  \label{subsec:key-features}

  \subsection{Tooling and Environment}
  \label{subsec:tooling}

  \subsection{Code Examples...}
  \label{subsec:code-examples}